This is versor.info, produced by makeinfo version 4.7 from
versor.texinfo.

START-INFO-DIR-ENTRY
* versor::			Versatile cursors.
END-INFO-DIR-ENTRY


File: versor.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

    This file documents versor, the versatile cursor system. 
This document applies to version 1 of versor.  Versor, the
"versatile cursor" package, provides, and makes easily accessible,
cursor movements in a variety of groups of "dimensions", such as: 
                         pages             lines         chars
            functions    depth of          expressions   chars
                         nesting                         
paragraphs  sentences    phrases           words         chars
functions   statements   statement-parts   expressions   chars
    Versor is one of a pair of companion packages. The other one,
Languide, provides some high-level editing operations. Part of
Versor's functionality is provided by the lower-level parts of
Languide. *Note Languide and Versor: (languide)Languide and Versor, for
more information. 

* Menu:

* Introduction::                The concepts behind Versor
* Familiarization::             Learning your way around Versor
* Dimensions::                  Available coordinate systems
* Further commands::            Commands other than movement
* Refactoring::                 Refactoring using Languide
* Advanced features::           More advanced features
* Accessibility::               Using Versor when avoiding keyboard use
* Versor and Languide::         Interfaces to a companion package
* Setup::                       How to install and configure Versor
* Analysis::                    Versor use analysis
* Versor and research::         Versor and research
* Command Index::               Command Index
* Concept Index::               Concept Index

 --- The Detailed Node Listing ---

Introduction

* Aims::                        The aims of Versor
* Concepts::                    The concepts behind Versor

Concepts

* Coordinates and dimensions::  Coordinate systems and dimensions
* The selection::               The selection

Familiarization

* Zooming::                     Zooming within a coordinate system
* Switching coordinate systems::  Switching between coordinate systems
* Editing with the selection::  
* Extending::                   Extending the selection

Editing with the selection

* Deleting the selection::      
* Inserting using the selection::  

Available coordinate systems

* Cartesian::                   Cartesian coordinates
* Structural::                  Structural coordinates
* Text::                        Text coordinates
* Structured Text::             Structured Text coordinates
* Tables::                      Table coordinates
* Program::                     Program coordinates

Further commands

* Deletion::                    Deletion
* Insertion::                   Insertion
* Alteration::                  Alteration
* DWIM::                        Do What I Mean

Refactoring using Languide

* Expression handling::         Commands working on expressions
* Statement handling::          Commands working on statements
* Summary of refactoring::      Key bindings for refactoring

Expression handling, expressions, and functions

* Convert to variable::         Convert selection to variable
                                Given a selection containing an
                                expression, this sets up a variable
                                initialised to that expression, and
                                replaces the original expression with
                                that variable.
* Convert to function::         Convert selection to function
                                This takes the selection,
                                defines a new function just before the
                                one containing the selection, and
                                replaces the original selection with a
                                call to the new function.
* Surround with call::          Surround selection with call
                                This wraps the selection with a
                                call to a function.
* Remove call::                 Remove surrounding call
                                This removes the function call
                                surrounding point.

Statement handling

* Unify Statements::            Unify Statements
                                This makes the selection into a
                                compound statement. 
* Make conditional::            Make the selected code conditional
* Make repeating::              Make the selected code iterative
* Remove control::              Remove a control construct
* Decision point::              Move to enclosing decision point
                                This moves point to the most nearly
                                enclosing decision point, that is, a
                                suitable place for putting a new condition.

Advanced features

* Detect text in code::         Text in code
* Per-buffer dimensions::       Per-buffer dimensions
* Per-mode dimensions::         Per-mode dimensions

Accessibility

* Pedals::                      Using pedals
* Reversing::                   Reversing the cursor motions
* Voice input::                 Using voice input
* Flexi-choose::                The flexible chooser
* Other input devices::         Future interface possibilities

Setup

* General configuration::       Some options to set when loading
* Dimensions available::        Dimensions you can choose from, for each mode
* Using Configure::             Configuring versor using M-x configure

Using Configure

* Motion::                      
* Status::                      
* Other control::               

Motion

* Allow move to end of last::   
* Move out when at end::        
* Statement up to next::        
* Level wrap::                  
* Meta level wrap::             
* Reversible::                  

Status

* Multi line level display::    
* Use face attributes::         
* Highlight with brackets::     
* Change cursor color::         
* Item attribute::              
* Try to display whole item::   
* Mode line begin string::      
* Mode line end string::        
* Item face::                   

Other control

* Statement insertion with dummy value::  
* Per buffer::                  
* Auto change for modes::       
* Text in code::                
* Announce text in code::       
* Text faces::                  
* Live commentary::             
* Display full choices::        
* Flexi choose upstring::       
* Flexi choose topstring::      

   


File: versor.info,  Node: Introduction,  Next: Familiarization,  Prev: Top,  Up: Top

1 Introduction
**************

 Versor provides, and makes easily accessible, cursor movements in a
variety of groups of "dimensions", such as:  
                         pages             lines         chars
            functions    depth of          expressions   chars
                         brackets                        
paragraphs  sentences    phrases           words         chars
functions   statements   statement-parts   expressions   chars
    Some of these operations are already present in GNUemacs (but not
all of them easily reachable; some require complex chording, and some
may even need to be accessed through `M-x'), and some are added by
Versor. Versor puts them all in easy reach on the arrow keys. 
Although GNUemacs uses its modes to put the most useful commands for
each mode directly on single keys, there are more dimensions mentioned
above than will fit at the same time on the few arrow keys available
(just two dimensions). However, note that the available dimensions are
conveniently listed in a two-dimensional table, as above. 
Conveniently, the arrow keys provide two dimensions, just like the two
dimensions of the table above. Versor uses the arrow keys themselves,
with a modifier key, to select a pair of adjacent dimensions from one
of the rows above, and assign them to the arrow keys.  You will
notice (unless your display cannot render this) that a unit of text,
of the same size as the dimension you are using, will be highlighted,
after each Versor command. This is what Versor regards as the cursor.
The normal GNUemacs cursor appears at the start of it (or
occasionally at the end), and all normal GNUemacs operations are
available and will use the normal cursor. In GNUemacs versions from 21
onwards, the colour of highlighting changes to indicate the current
dimension; there is also an indication in the mode line.  The
Versor highlight cursor disappears at the start of every command (and
is restored at the end of each Versor command), so when you use
GNUemacs commands other than Versor commands, Versor quietly becomes
invisible, until you use one of its commands again. 

* Menu:

* Aims::                        The aims of Versor
* Concepts::                    The concepts behind Versor
   


File: versor.info,  Node: Aims,  Next: Concepts,  Prev: Introduction,  Up: Introduction

1.1 The aims of Versor
======================

 Although we have the computer power to edit programs in more
abstract terms than characters and lines, and many "natural"
programmers have the thought power to do so, editing is still often
done character-by-character, which seems to be inefficient,
unreliable, and a waste of human effort. Versor aims to move beyond
that.  Versor is also part of a research project (*note Versor
and research::), which looks into whether programmers really have moved
on from thinking of edits in terms of the lines of characters that
they see on paper listing and on editor screen.  Ideally
(especially for those whose hands are becoming tired of keyboard use)
it should be possible to enter and edit programs with very little
handling of individual characters. Versor tries to get as close to
this as possible. (It includes an analysis facility (*note
Analysis::) to see well it is doing in this, with each particular
programmer.) All that need be entered character by character are new
identifiers and comments. It may even be possible in future versions
to offer a selection of suitable names for variables in certain
circumstances, such as `i' for a first index variable, as some of
these are quite stereotyped by role. 


File: versor.info,  Node: Concepts,  Prev: Aims,  Up: Introduction

1.2 Concepts
============

 The main concepts within versor are the coordinate system, the
dimension, and the selection.   It may be helpful to think of the
arrow keys as being two dimensions, "Major" and "Minor"; some of the
documentation refers to them in these terms. The way that major and
minor dimensions are related in versor is often analogous to the way
they are related in their traditional use for cartesian coordinates:
keeping going in the minor dimension unto you reach the end of a
major dimension unit will take you into the next unit in the major
dimension.  

* Menu:

* Coordinates and dimensions::  Coordinate systems and dimensions
* The selection::               The selection
   


File: versor.info,  Node: Coordinates and dimensions,  Next: The selection,  Prev: Concepts,  Up: Concepts

1.2.1 Coordinate systems and dimensions
---------------------------------------

 A "dimension" is a group of related movement commands, defining the
following movements for the same kind of text unit: 
   * first

   * previous

   * next

   * last
    A "coordinate system" is a group of related dimensions.  


File: versor.info,  Node: The selection,  Prev: Coordinates and dimensions,  Up: Concepts

1.2.2 The selection
-------------------

 The selection is best thought of as a cursor, although it looks
more like a GNUemacs transient region. It is normally displayed by
setting the background colour of the text it contains.  Versor
editing operations act on the selection; for example, the versor
"Delete" command deletes the current selection.   The selection
covers one or more units of the current dimension (*note Coordinates
and dimensions::).  


File: versor.info,  Node: Familiarization,  Next: Dimensions,  Prev: Introduction,  Up: Top

2 Familiarization
*****************

 The easiest way to start finding your way around Versor is to start
trying things. You will first need to install Versor (*note Setup::),
and call its initialisation function, indicating which set of arrow
keys you wish it to use.  Versor can use either the keypad
arrows, or the normal arrow keys. Because it is often useful to mix
traditional movements with Versor movements, it is recommended that
you give Versor only one set of arrow keys. The explanations here
will be phrased in terms of the main arrow keys and the key cluster
that, on typical keyboards, is just above them. *Note Setup::, for
how to set Versor up to use a particular set of keys.  The
clearest demonstration of the basic facilities of Versor is probably
to be had with a buffer containing a large number of Lisp functions,
some of them with very deeply nested expressions. Since Versor
provides commands for modification as well as navigation, we suggest
you take a copy of your sample material!  Unless customised to do
otherwise (*note Setup::), Versor will start in its `cartesian"
coordinate system, which is similar to the normal cursor keys: you
can move left or right with the <LEFT> and <RIGHT> arrow keys, and up
and down with the <UP> and <DOWN> arrow keys. (You can change the
initial coordinate system, on a mode by mode basis.) 

* Menu:

* Zooming::                     Zooming within a coordinate system
* Switching coordinate systems::  Switching between coordinate systems
* Editing with the selection::  
* Extending::                   Extending the selection
   


File: versor.info,  Node: Zooming,  Next: Switching coordinate systems,  Prev: Familiarization,  Up: Familiarization

2.1 Zooming within a coordinate system
======================================

  The `LEFT' and `RIGHT' Meta arrows zoom in and out within a
coordinate system.  You can zoom out along a series of coordinates
by typing `M-LEFT'. Now the minor cursor keys (`LEFT' and `RIGHT'
arrows) will select previous and next lines of the buffer, and the
major cursor keys (`UP' and `DOWN' arrows) will move by whole pages.
You will also see that when you move by lines, a whole line is
highlighted in a particular colour.  This is the current "versor
selection", and its colour provides feedback on the currently
selected dimension.   `M-RIGHT' zooms back in; the finest scale in
most coordinate systems is the character. 


File: versor.info,  Node: Switching coordinate systems,  Next: Editing with the selection,  Prev: Zooming,  Up: Familiarization

2.2 Switching between coordinate systems
========================================

 The `UP' and `DOWN' Meta arrows switch between coordinate
systems.  Starting from the "cartesian" coordinate system, typing
`M-down' will select a "structural" coordinate system, and if your
current dimension was the second one, "lines", you should now be in
the second of the structural coordinates, which is "exprs", that is,
"expressions". The minor cursor keys will now select previous and
next s-expressions (you will see the current expression is
highlighted), and the major cursor keys will select the depth (you
will see the pair of brackets highlighted - Versor can use multipart
selections).  You can control which dimensions are available in
each mode (*note Dimensions available::). 


File: versor.info,  Node: Editing with the selection,  Next: Extending,  Prev: Switching coordinate systems,  Up: Familiarization

2.3 Editing with the selection
==============================

 Versor provides some editing commands which act on the current
selection.  

* Menu:

* Deleting the selection::      
* Inserting using the selection::  
   


File: versor.info,  Node: Deleting the selection,  Next: Inserting using the selection,  Prev: Editing with the selection,  Up: Editing with the selection

2.3.1 Deleting the selection
----------------------------

 Pressing `delete' while using versor will delete the current
versor selection.  If it is a multipart selection, such as an opening
bracket and the corresponding closing bracket (as selected by the
versor "bracket nesting" dimension), all parts of the selection will
be deleted, and will become successive elements of the kill ring. 



File: versor.info,  Node: Inserting using the selection,  Prev: Deleting the selection,  Up: Editing with the selection

2.3.2 Inserting with the selection
----------------------------------

 Pressing `insert' while using versor can do many kinds of
insertion. The first thing to choose is whether you are inserting
before, after, or around, the selection. Each of these may be done by
pressing the `left', `right', or `up' arrow keys respectively. 
Inserting around the selection will insert one item from the kill ring
before the selection, and the next item after it.  This is the
counterpart of deleting a multipart selection, such as a balanced pair
of brackets.   Having chosen where to insert, you then press
another key to decide what to insert. The most common ones here will
be `delete', to insert the most recently deleted text, and `(' to
insert a pair of parentheses.  If inserting around the selection,
you can type `?' to wrap an `if' statement around the selection, `@'
to wrap a `while' statement around it, `=' to wrap a scoping
construct around it (like `let' in Lisp), `&', `|' or `!' to wrap an
`and', `or', or `not' expression around it.   *Note Insertion::,
for full details of the possible kinds of things to insert. 


File: versor.info,  Node: Extending,  Prev: Editing with the selection,  Up: Familiarization

2.4 Extending the selection
===========================

 You can also extend the selection, using `C-right' and `C-left'.
If you start by moving right, the extension grows from the end of the
current selection, and moving left will shrink the extension. If you
start by moving left, the extension grows from the beginning of the
current selection, and moving right will shrink the extension. 


File: versor.info,  Node: Dimensions,  Next: Further commands,  Prev: Familiarization,  Up: Top

3 Available coordinate systems
******************************

 This section describes the coordinate systems which Versor
provides. By default, all coordinates systems are available in all
modes. *Note Dimensions available::, for how to restrict this, on a
mode by mode basis, to just the coordinates most likely to be useful
in that mode. 

* Menu:

* Cartesian::                   Cartesian coordinates
* Structural::                  Structural coordinates
* Text::                        Text coordinates
* Structured Text::             Structured Text coordinates
* Tables::                      Table coordinates
* Program::                     Program coordinates
   


File: versor.info,  Node: Cartesian,  Next: Structural,  Prev: Dimensions,  Up: Dimensions

3.1 Cartesian coordinates
=========================

  Cartesian coordinates is the Versor dimension most similar to the
normal cursor keys. The main difference you will notice is that when
you have selected "lines" as your current dimension, you will see a
whole line highlighted.   The dimensions available in cartesian
coordinates are as follows: 
   * characters 

   * lines 

   * pages
   


File: versor.info,  Node: Structural,  Next: Text,  Prev: Cartesian,  Up: Dimensions

3.2 Structural coordinates
==========================

 Structural coordinates uses bracketing characters to navigate by
s-expressions (*note Expressions: (emacs)Expressions.). Moving in the
"depth" dimension leaves the selection split into the opening and
closing brackets.  The dimensions available in structural
coordinates are as follows: 
   * chars

   * exprs

   * depth

   * defuns
    


File: versor.info,  Node: Text,  Next: Structured Text,  Prev: Structural,  Up: Dimensions

3.3 Text coordinates
====================

 Text coordinates works in terms of natural language units such as
words and phrases.   The dimensions available in text coordinates
are as follows: 
   * chars

   * words

   * phrases

   * sentences

   * paragraphs
    Navigating by words is slightly different from the emacs
`forward-word' command (*note Words: (emacs)Words.): it always leaves
the cursor on the first character of a word.  Navigating by phrases
uses the variable `phrase-end' to define the end of a phrase.  
The other dimensions in this group are based closely on the underlying
Emacs facilities. See *Note Sentences: (emacs)Sentences, and *Note
Paragraphs: (emacs)Paragraphs. 


File: versor.info,  Node: Structured Text,  Next: Tables,  Prev: Text,  Up: Dimensions

3.4 Structured Text coordinates
===============================

 Structured text coordinates are similar to text coordinates (*note
Text::), with the addition of moving by nested blocks as used in many
markup languages, in a manner similar to structural coordinates
(*note Structural::).  The dimensions available in structured text
coordinates are: 
   * chars

   * words

   * blocks

   * block-depth
    The definition of block syntax is mode-specific. For example, in
HTML, paired tags are defined to begin and end blocks.   An
associated command is `another-block' which analyzes the block before
point (that is, from a closing-block construct back to the
corresponding opening-block construct), collects up all the
structuring constructs in it, and inserts a copy of those at point.
For example, if point is just after an HTML table row (so that the tag
most immediately before point is `</tr>', the HTML table row ender),
`another-block' will find all the HTML tags back to the corresponding
`<tr>', and insert them, but without the intervening non-tag text.
(This specific example is probably the most useful use of this
command, in the author's experience.)  This part of Versor is very
much a work in progress, and you are encouraged to add to the
definition of block syntax for your favourite markup language, and
send it to the author of Versor. The block syntax mechanism is
defined in the file `nested-blocks.el'. 


File: versor.info,  Node: Tables,  Next: Program,  Prev: Structured Text,  Up: Dimensions

3.5 Table coordinates
=====================

 Table coordinates provides movements based on cells and rows, in
various modes for which these concepts are meaningful, such as
`tex-mode' and its variants, `html-mode' and `html-helper-mode'. 
 The dimensions defined in table coordinates are as follows: 
   * chars

   * cells

   * rows
   


File: versor.info,  Node: Program,  Prev: Tables,  Up: Dimensions

3.6 Program coordinates
=======================

 Program coordinates uses the syntax of programming languages to
guide to the cursor movements. This uses the accompanying package,
Languide (*note Top: (languide)Top.), to provide the primitives for
moving around source code. It is, of course, mode-specific. 
Languide definitions are already reasonably comprehensive for Lisp, C,
Perl and Java, in progress for shell scripts, and planned for Haskell
and Python. They would probably not be meaningful for PostScript. You
are encouraged to contribute further or better definitions, both for
the languages already covered and for others.  The dimensions
defined in program coordinates are as follows: 
   * chars

   * exprs

   * statement parts

   * statements

   * defuns
    Apart from the statement-related dimensions, these are the same
as those in structural coordinates *Note Structural::.   Movement
by statement parts moves the selection between parts of the current
statement.  Programming language statements can typically be divided
into two or three parts, as follows: 
  1. The head of a statement is often a condition, such as in an `if'
     or a `while' statement.

  2. The body of a statement is typically another statement, or a group
     of statements, such as the body of an `if' or a `while'
     statement.

  3. The tail of a statement occurs in only a few statement types, such
     as `if-then-else' or `try-catch-finally'. 
         The "statement parts" dimension will move between these in
turn, and can also moved to the "container" of the current statement,
that is, a grouping statement surrounding it.   when you select
the body of a statement, and the body is a compound statement, you
can then either: 
   * continue moving to other parts of the same statement

   * select statements within the body, by using the "statements"
     dimension movements
     If using voice input (*note Voice input::), it is convenient
to define commands such as "head", "body",and "container", so that
you can jump directly to the one you want rather than treating it as
part of a sequence. The commands `navigate-this-head',
`navigate-this-body', `navigate-this-tail', `navigate-this-whole',
and `navigate-this-container' are available for binding directly to
voice commands (or, for that matter, to keys of their own).  The
"statement" dimension moves between successive statements at the same
structural level. This is different from the statement movements
provided as part of the GNUemacs' C-mode, which moves in and out of
compound statements.  


File: versor.info,  Node: Further commands,  Next: Refactoring,  Prev: Dimensions,  Up: Top

4 Further commands
******************

 As well as redefining the arrow keys, Versor takes over a few other
keys as well. The most noticeable of these is that `DEL' now deletes
the current Versor selection.  

* Menu:

* Deletion::                    Deletion
* Insertion::                   Insertion
* Alteration::                  Alteration
* DWIM::                        Do What I Mean
   


File: versor.info,  Node: Deletion,  Next: Insertion,  Prev: Further commands,  Up: Further commands

4.1 Deletion
============

 Versor defines the `DEL' key to delete the current selection. Note
that if this is a multipart selection, such as a pair of opening and
closing brackets, all parts of it are deleted.   Deleting a
multipart selection puts the parts of it into separate entries in the
kill-ring. This is compatible with Versor's insertion commands (*note
Insertion::) while also keeping compatibility with normal Emacs
kill-ring use. 


File: versor.info,  Node: Insertion,  Next: Alteration,  Prev: Deletion,  Up: Further commands

4.2 Insertion
=============

 Pressing the `INS' key gives you a choice of several ways to
insert, which you choose between by pressing one of the Versor arrow
keys.  The `LEFT' and `RIGHT' arrow keys let you insert before or
after the selection.  The `UP' arrow key inserts two entries from
the kill ring, one before and one after the selection; that is to
say, it inserts around the selection. This is compatible with
Versor's way of deleting a multipart selection such as a pair of
opening and closing brackets *Note Deletion::.  These are defined
in `versor:insertion-placement-keymap'.  Having chosen where to
make an insertion, you must choose which one of several kinds of
things to insert.  The choices are as follows: 
     

`delete'

`DEL'

`C-y'
     The top item(s) on the kill ring 

`1..9'
     The top N items on the kill ring 

`C-s'
     the most recent search string 

`('

`['

`{'

`<'
      A pair of brackets, the opening bracket being the character
     typed 

`?'
     An `if-then' statement in the programming language handled by the
     current major mode. This is meant for use when inserting around
     the selection; it wraps the selection in the conditional
     statement. Statement insertions such as this are very basic
     string insertions; Languide (*note Alterations:
     (languide)Alterations.)  has more sophisticated ones, which use
     the template and skeleton insertion systems, and can maintain
     indentation and spacing better. 

`%'
     An `if-then-else' statement in the programming language handled by
     the current major mode. 

`@'
     A `while' statement in the programming language handled by the
     current major mode. 

`='
     A variable declaration in the programming language handled by the
     current major mode 

`&'

`|'

`!'
     An "and", "or" or "not" expression in the programming language
     handled by the current major mode 

`f'
     The name of the file in the next window. (if there is only one
     window, the name of the file in that window is inserted). 
   


File: versor.info,  Node: Alteration,  Next: DWIM,  Prev: Insertion,  Up: Further commands

4.3 Alteration
==============

 The "alterations" system provides a Versor style interface to
changing the text of the current Versor selection. While you are doing
alterations, the <LEFT> and <RIGHT> cursor keys change the text within
the selection, between several possible values of the same kind.  The
<UP> and <DOWN> cursor keys change which kind of thing you are
choosing between.   The effect is similar to turning the
selection into a little window behind which you are scrolling a
two-dimensional grid of possible values.   For example, you could
use the <LEFT> and <RIGHT> keys to put any local variable which is
currently in scope into the selection, and <UP> and <DOWN> keys to
switch between selecting local variables, global variables, and
expressions wrapped around a variable.   When you have got the text
you want into the selection, you can use a "select" key to accept
that selection, or a "reject"  key to go back to the original value.
  The selection of types of value depends on the context. Possible
types include: 
   * local variables

   * global variables

   * tags in your tag table

   * functions defined in this file

   * reserved words in a programming language
    The data used by Versor's "alteration" feature is provided by
the companion package, Languide (Language Guided Editing). *Note
Alterations: (languide)Alterations, for details. 


File: versor.info,  Node: DWIM,  Prev: Alteration,  Up: Further commands

4.4 Do What I Mean
==================

 Sometimes Versor deviates from its most logical design, to make
sure that the cursor ends up where you are likeliest to want it.  
An example of this is that if you are moving by s-expressions, and
move forward from the last one in the enclosing expression, the cursor
moves to the end of the last expression, and then on past any
whitespace and comments, ending up where you are likely to want to
type the next s-expression.  However, it is still not always
possible to get to exactly the right place without using
character-level movements. For these circumstances, Versor provides a
"Do What I Mean" (DWIM) command, which moves the cursor to a point
likely to be of interest that is otherwise hard to get at using the
current Versor dimension. This command is normally bound to the key
`M-home'. Alternatively, it can be accessed with `M-x versor:dwim'.
 This function reads the user's mind, using the following algorithm:

  1.   Tell the user what has been done each time;

  2.   Eventually, the user will come to expect the behaviour of this
      function;

  3.   Reading what the user wants Versor to do should then usually be
      trivial.
         Aspects of mental state not necessary for figuring out where
to leave point are factored out of the calculations. 
`versor:dwim' is mode-specific in its behaviour. For example, in
programming language modes, it can move point in and out of string
constants and comments. 


File: versor.info,  Node: Refactoring,  Next: Advanced features,  Prev: Further commands,  Up: Top

5 Refactoring using Languide
****************************

 Some more sophisticated commands, replacing long sequences of
manual keyboard labour by the programmer, are provided by the
companion package, Languide. As described here, they are accessed
through some wrapper functions which apply them to the versor
selection. You can also access these directly to act on GNUemacs
region; *Note Top: (languide)Top.  A typical action (probably the
one the author uses most often) is converting an expression to a
local variable (so that the value can be re-used), involving the
following steps: 
  1. examine the expression for the variables it needs

  2. find the nearest scoping point, or (with a prefix arg) the widest
     scoping point at which all the variables needed are defined

  3. deduce the type of the expression (in statically typed languages
     only)

  4. insert a declaration for a variable (with the name supplied by
     the user) at the chosen scoping point, and initialize it using
     the original expression

  5. replace the original expression with a use of the new variable

  6. leave the new variable at the top of the kill ring, ready to be
     inserted somewhere else

  7. 
         Likewise, there is a function to turn a block of code into a
function (working out automatically what needs to be passed in as the
argument list), and replace its original occurrence with a call to
the new function.  To draw attention to what they have done,
these functions highlight, with a red background, any changes they
make away from the cursor. The highlighting is not the Versor
selection, and is removed on your next input to GNUemacs.  These
commands are divided into two groups, one of them acting on
expressions (as used in both functional and imperative languages) and
one acting on statements, as used in imperative languages.  

* Menu:

* Expression handling::         Commands working on expressions
* Statement handling::          Commands working on statements
* Summary of refactoring::      Key bindings for refactoring
   


File: versor.info,  Node: Expression handling,  Next: Statement handling,  Prev: Refactoring,  Up: Refactoring

5.1 Expression handling, expressions, and functions
===================================================

 This group of commands manipulates value handling constructs in
source code.  For example, you can select an expression (using the
Versor selection), and turn it into a variable, so that you can
re-use the same value.  Likewise, you can convert an expression into
a function, so that you can call it elsewhere.  

* Menu:

* Convert to variable::         Convert selection to variable
                                Given a selection containing an
                                expression, this sets up a variable
                                initialised to that expression, and
                                replaces the original expression with
                                that variable.
* Convert to function::         Convert selection to function
                                This takes the selection,
                                defines a new function just before the
                                one containing the selection, and
                                replaces the original selection with a
                                call to the new function.
* Surround with call::          Surround selection with call
                                This wraps the selection with a
                                call to a function.
* Remove call::                 Remove surrounding call
                                This removes the function call
                                surrounding point.
   


File: versor.info,  Node: Convert to variable,  Next: Convert to function,  Prev: Expression handling,  Up: Expression handling

5.1.1 Convert selection to variable
-----------------------------------

 The command `versor:convert-selection-to-variable' takes the
current selection as an expression, sets up a variable (at the nearest
scoping point) initialised to that expression, and replaces the
original expression with that variable.  In the normal Versor key
bindings, this command is bound to `C-insert ='.   With a prefix
arg, this tries to find the widest scope in which all the necessary
variables are bound, thus making the value re-usable over as much
code as possible. However, it does not (in the current version of
Versor/Languide) take note of assignments to those variables, so this
may not be the one you want. Future versions of the software should
handle this correctly. 


File: versor.info,  Node: Convert to function,  Next: Surround with call,  Prev: Convert to variable,  Up: Expression handling

5.1.2 Convert selection to function
-----------------------------------

 The command `versor:convert-selection-to-function' takes the
selection, defines a new function just before the one containing the
selection, and replaces the original selection with a call to the new
function. It examines the selection and the surrounding code, to find
any variables referred to in the selection but defined outside it,
and makes those into arguments to the new function.  In the
normal Versor key bindings, this command is bound to `C-insert f'. 



File: versor.info,  Node: Surround with call,  Next: Remove call,  Prev: Convert to function,  Up: Expression handling

5.1.3 Surround selection with call
----------------------------------

 The command `versor:surround-selection-with-call' wraps the
selection with a call to a specified function, such that the
selection becomes the argument list of the function.  In the normal
Versor key bindings, this command is bound to `C-insert ('.   



File: versor.info,  Node: Remove call,  Prev: Surround with call,  Up: Expression handling

5.1.4 Remove surrounding call
-----------------------------

 The command `versor:remove-function-call' removes the function
call surrounding the selection. This leaves the function arguments in
place of the call.  In the normal Versor key bindings, this command
is bound to `C-insert )'.    


File: versor.info,  Node: Statement handling,  Next: Summary of refactoring,  Prev: Expression handling,  Up: Refactoring

5.2 Statement handling
======================

 This group of commands acts mostly on imperative statements.  

* Menu:

* Unify Statements::            Unify Statements
                                This makes the selection into a
                                compound statement. 
* Make conditional::            Make the selected code conditional
* Make repeating::              Make the selected code iterative
* Remove control::              Remove a control construct
* Decision point::              Move to enclosing decision point
                                This moves point to the most nearly
                                enclosing decision point, that is, a
                                suitable place for putting a new condition.
   


File: versor.info,  Node: Unify Statements,  Next: Make conditional,  Prev: Statement handling,  Up: Statement handling

5.2.1 Unify Statements
----------------------

 The command `versor:unify-statements' turns the current Versor
selection into a compound statement.  In the normal Versor key
bindings, this command is bound to `C-insert {'. 


File: versor.info,  Node: Make conditional,  Next: Make repeating,  Prev: Unify Statements,  Up: Statement handling

5.2.2 Make conditional
----------------------

 The command `versor:make-conditional' makes the selection
conditional, and positions point ready for filling in the condition.
If the selection is already the body of a conditional construct, an
`and' construct is wrapped around the existing condition (unless it
already has one) and point is positioned for adding a further
condition.  In the normal Versor key bindings, this command is
bound to `C-insert ?'.  


File: versor.info,  Node: Make repeating,  Next: Remove control,  Prev: Make conditional,  Up: Statement handling

5.2.3 Make repeating
--------------------

 The command `versor-make-iterative' makes the selection be the
body of a repeating construct, and positions point ready for filling
in the repeat condition.  This command is not yet implemented. 


File: versor.info,  Node: Remove control,  Next: Decision point,  Prev: Make repeating,  Up: Statement handling

5.2.4 Remove control construct
------------------------------

 The command `versor-remove-control' removes the control construct
most closely surrounding the selection.  This command is not yet
implemented. 


File: versor.info,  Node: Decision point,  Prev: Remove control,  Up: Statement handling

5.2.5 Enclosing decision point
------------------------------

 The command `languide-enclosing-decision-point' moves point to the
most nearly enclosing decision point, that is, a suitable place for
putting a new condition. This is largely used as an internal function
by Languide, but is also exposed for direct use in case it is
useful. 


File: versor.info,  Node: Summary of refactoring,  Prev: Statement handling,  Up: Refactoring

5.3 Summary of refactoring commands
===================================

 In the default configuration, Versor's refactoring commands begin
with `C-insert'. The following keys may be used following this: 
`='
     convert selection to variable

`f'
     convert selection to function

`g'
     convert selection to global variable

`('
     surround selection with call

`)'
     remove function call around selection

`{'
     unify selected statements

`?'
     make selected statements conditional

`@'
     make selected statements iterative

`;'
     comment selection
   


File: versor.info,  Node: Advanced features,  Next: Accessibility,  Prev: Refactoring,  Up: Top

6 Advanced features
*******************



* Menu:

* Detect text in code::         Text in code
* Per-buffer dimensions::       Per-buffer dimensions
* Per-mode dimensions::         Per-mode dimensions
   


File: versor.info,  Node: Detect text in code,  Next: Per-buffer dimensions,  Prev: Advanced features,  Up: Advanced features

6.1 Detect text in code
=======================

 You can make Versor remember different current dimensions for
actual code, and for the insides of comments and string literals. You
can turn this on by requiring the feature `versor-text-in-code' and
setting the variable `versor:text-in-code' to anything other than
`nil'; or by including the symbol `text-in-code' in the arguments to
`versor:setup', which does both of the above. 


File: versor.info,  Node: Per-buffer dimensions,  Next: Per-mode dimensions,  Prev: Detect text in code,  Up: Advanced features

6.2 Per-buffer dimensions
=========================

 You can make Versor remember different current dimensions for each
buffer. You can do this by requiring the feature `versor-local' and
setting the variable `versor:per-buffer' to anything other than
`nil'; or by including the symbol `local' in the arguments to
`versor:setup', which does both of the above. 


File: versor.info,  Node: Per-mode dimensions,  Prev: Per-buffer dimensions,  Up: Advanced features

6.3 Per-mode dimensions
=======================

   You can make Versor remember different current dimensions for
each mode. You can do this by requiring the feature `versor-modal'
and setting the variable `versor:auto-change-for-modes' to non-nil;
or by including the symbol `modal' in the arguments to
`versor:setup', which does both of the above. 


File: versor.info,  Node: Accessibility,  Next: Versor and Languide,  Prev: Advanced features,  Up: Top

7 Accessibility
***************

 Versor is designed to be usable not only through a conventional
keyboard, but also through narrow interfaces such as pedals, and
through voice recognition. 

* Menu:

* Pedals::                      Using pedals
* Reversing::                   Reversing the cursor motions
* Voice input::                 Using voice input
* Flexi-choose::                The flexible chooser
* Other input devices::         Future interface possibilities
   


File: versor.info,  Node: Pedals,  Next: Reversing,  Prev: Accessibility,  Up: Accessibility

7.1 Using pedals
================

 The setup used by the author requires six pedals, arranged in two
sets of three. The pedals are daisy-chained into the keyboard
connector, and duplicate the actions of selected keys. One set
provides the modifiers <Control>, <Shift> and <Alt>, and the other
provides three types of action, referred to here as <Other>, <Move>,
and <Select>.  If using the common commercially available pedals in
which each unit has a large central pedal and a smaller pedal along
each side, the recommended setup puts <Shift> and <Move> onto the
large pedals.  <Move> is the main action, moving forward in the
current dimension, and corresponds to the <Right> cursor key.
`S-Move' moves in the other direction in the same dimension. 
<Other> and `S-Other' provide the <DOWN> and <UP> actions of Versor.
 <Select> brings up a menu, using the Text Mode Menus (*note Menu
Bar: (emacs)Menu Bar.), and you can then move along the menu using
<Move> and `S-Move', and select an entry using <Select>, which will
either bring up a further menu, or run the selected command. 
Some of these commands read their arguments through a system built on
top of completing-read, that is designed to allow fast selection of
possibilities without needing typing. *Note Flexi-choose::, for
details of this. 


File: versor.info,  Node: Reversing,  Next: Voice input,  Prev: Pedals,  Up: Accessibility

7.2 Reversing the cursor motions
================================

 To make Versor usable with a very small number of keys (for example,
a mouthswitch), it is possible to reverse the motion of Versor's
"forward" and "back" commands (of all kinds, both dimensions and both
meta-dimensions (ways of choosing dimensions). This is available
through the command `versor:reverse'. If reversing is used, it
appears in the mode line as an arrow at the appropriate end of the
dimension indication.  This is an extreme solution, for extreme
problems. It's unlikely to be useful if you can use Versor in other
ways. 


File: versor.info,  Node: Voice input,  Next: Flexi-choose,  Prev: Reversing,  Up: Accessibility

7.3 Using voice input
=====================

 Some parts of Versor are particularly suited to use with voice
input, such as vr-mode `http://emacs-vr-mode.sourceforge.net/'. 
Some of the voice or menu commands read their arguments through a
system built on top of completing-read, that is designed to allow fast
selection of possibilities without needing typing. *Note
Flexi-choose::, for details of this. 


File: versor.info,  Node: Flexi-choose,  Next: Other input devices,  Prev: Voice input,  Up: Accessibility

7.4 The flexible chooser
========================

 Flexi-choose splits a list of choices into a tree, and allows
navigation down the tree without having to either type parts of an
entry, nor having to scroll past all the ones before the one you want.
It uses similar techniques to Text Mode Menus (*note Menu Bar:
(emacs)Menu Bar.), but constructs the menu tree on the fly.  If
used with a voice extension (contact the author for details), it is
possible to say a word which occurs in the entry you want, and have
the list of choices redisplayed with only the entries that match that
word. Saying another word will narrow it down further, and so on. When
the list is down to a single entry, that one is then selected
automatically. 


File: versor.info,  Node: Other input devices,  Prev: Flexi-choose,  Up: Accessibility

7.5 Other input devices
=======================

 As well as pedals (*note Pedals::) it should be possible to extend
versor to use other input devices, such as joysticks and
mouthswitches.  For commands suitable for use with very
"narrow-channel" input devices, *Note Reversing::.  A complex
joystick (at least with twist as well as X and Y movements) could
prove to be an excellent way to use versor. The main stick movements
could be the main versor movements, and a side twist could either
change dimensions or do alterations. Alternatively, a Fire button
could switch the main co-ordinates between movement and alterations.
Some joysticks have a smaller joystick mounted on the main joystick;
that would be another way to access alterations or dimension changes.
A button on the side of the joystick could also change the main
movements between navigating the buffer and navigating the space of
coordinates. 


File: versor.info,  Node: Versor and Languide,  Next: Setup,  Prev: Accessibility,  Up: Top

8 Versor and Languide
*********************

 Language provides "language guided editing", guiding editing
operations using the syntax of the file being edited.  The
statement-based dimensions of Versor use the lower levels of
Languide, and the refactoring operations use the higher levels of it.
 Languide is a cross-language package, with definitions for several
popular programming languages.  *Note Languide and Versor:
(languide)Languide and Versor, for languide's end of the story.. 


File: versor.info,  Node: Setup,  Next: Analysis,  Prev: Versor and Languide,  Up: Top

9 Setup
*******

 To install Versor, unpack the tarball into a suitable directory,
and put that directory on your load-path.  From your .emacs, for
the default setup, call 
       (require 'versor)
       (versor:setup)
   

* Menu:

* General configuration::       Some options to set when loading
* Dimensions available::        Dimensions you can choose from, for each mode
* Using Configure::             Configuring versor using M-x configure
   


File: versor.info,  Node: General configuration,  Next: Dimensions available,  Prev: Setup,  Up: Setup

9.1 General configuration
=========================

 You can control which keys are used, and which other facilities are
turned on, by giving some symbols as arguments to `versor:setup'. 
The arguments can be any (combination) of 
     

`arrows'
     for the main cursor keys 

`arrows-misc'
     for insert, delete etc 

`keypad'
     for the keypad cursor keys 

`keypad-misc'
     for keypad insert, delete etc
    to select which keys are set up to do Versor commands.  You
can turn on further facilities by including the following symbols
amongst the arguments: 
     

`modal'
     remember a different dimension for each mode 

`local'
     remember a different dimension for each buffer 

`text-in-code'
     switch dimensions for string literals and comments, allowing
     code-oriented movement in actual code, and text-oriented
     movement in embedded natural language text 

`menu'
     define a menu of Versor commands
    The recommended default setup is: 
     (versor:setup 'arrows 'arrows-misc 'modal 'text-in-code 'menu)
    You may then want to customize it further, like this: 
       ;; preset the dimensions for some modes
       (setq versor:mode-current-levels 
     	    (mapcar 'versor:mode-levels-triplet
     		    '(
     		      (emacs-lisp-mode "structural" "exprs")
     		      (lisp-interaction-mode "structural" "exprs")
     		      (c-mode "program" "statement-parts")
     		      (text-mode "cartesian" "lines")
     		      (html-helper-mode "text" "words")
     		      )))
   


File: versor.info,  Node: Dimensions available,  Next: Using Configure,  Prev: General configuration,  Up: Setup

9.2 Dimensions available for each mode
======================================

 The variable `versor:meta-dimensions-valid-for-modes' controls
which meta-dimensions are valid for which major modes.  If t, all
meta-dimensions are allowed in all major modes.  Otherwise, it is
an alist mapping modes to sublists describing the meta-dimensions
allowed in that mode.  Each sublist should begin with t, to
indicate that only the meta-dimensions listed are to be allowed, or
nil, to indicate that all meta-dimensions except those listed are
allowed.  The rest of the sublist is the meta-dimensions allowed or
blocked for that mode.  The head of the node may also be a list
of major modes for which this rule applies.  A sublist for a
major mode t gives the defaults. 


File: versor.info,  Node: Using Configure,  Prev: Dimensions available,  Up: Setup

9.3 Using Configure
===================

  

* Menu:

* Motion::                      
* Status::                      
* Other control::               
   


File: versor.info,  Node: Motion,  Next: Status,  Prev: Using Configure,  Up: Using Configure

9.3.1 Motion
------------

 Control details for versor movements. 

* Menu:

* Allow move to end of last::   
* Move out when at end::        
* Statement up to next::        
* Level wrap::                  
* Meta level wrap::             
* Reversible::                  
   


File: versor.info,  Node: Allow move to end of last,  Next: Move out when at end,  Prev: Motion,  Up: Motion

9.3.1.1 Allow move to end of last
.................................

 Type: boolean  Default value: 'dwim  Whether to allow moving
to the end of the last sexp in a list.  Otherwise, versor-next
stops at the start of it, and refuses to do another forward move. 
Setting this non-nil does what you probably want in practice, although
setting it nil is probably cleaner in some abstract sort of way.
Setting it non-nil and not t will make the last move within a list go
to just before the closing syntax of the list, which is where you
typically want to be to type the next sexp in. 


File: versor.info,  Node: Move out when at end,  Next: Statement up to next,  Prev: Allow move to end of last,  Up: Motion

9.3.1.2 Move out when at end
............................

 Default value: t Type: boolean  If non-nil, trying to move
further on when already at the end of the last thing in a container
(see versor-allow-move-to-end-of-last will move to just after the end
of the container. Can be convenient in practice, although it breaks
the symmetry of the next<->previous operations. 


File: versor.info,  Node: Statement up to next,  Next: Level wrap,  Prev: Move out when at end,  Up: Motion

9.3.1.3 Statement up to next
............................

 Type: boolean  Default value: nil  Whether to make a
statement extend all the way to the start of the next one. This
highlights whitespace, and the author does not like it; but the code
can do it easily enough. 


File: versor.info,  Node: Level wrap,  Next: Meta level wrap,  Prev: Statement up to next,  Up: Motion

9.3.1.4 Level wrap
..................

 Type: boolean  Default value: t  Whether to wrap the level
changes.  If this is non-nil, going back from the first level takes
you to the last one, and going forward from the last level takes you
to the first one. 


File: versor.info,  Node: Meta level wrap,  Next: Reversible,  Prev: Level wrap,  Up: Motion

9.3.1.5 Meta level wrap
.......................

 Type: boolean  Default value: t  Whether to wrap the
meta-level changes.  If this is non-nil, going back from the first
meta-level takes you to the last one, and going forward from the last
meta-level takes you to the first one. 


File: versor.info,  Node: Reversible,  Prev: Meta level wrap,  Up: Motion

9.3.1.6 Reversible
..................

 Type: boolean  Default value: (not (eq window-system 'x)) 
Whether we allow reversing.  This is useful if you cannot use
\shift-next\ for \previous\. These seem to work OK on X but not on
Windows; not sure about other platforms/terminals yet. 


File: versor.info,  Node: Status,  Next: Other control,  Prev: Motion,  Up: Using Configure

9.3.2 Status
------------

 How versor displays its status information. 

* Menu:

* Multi line level display::    
* Use face attributes::         
* Highlight with brackets::     
* Change cursor color::         
* Item attribute::              
* Try to display whole item::   
* Mode line begin string::      
* Mode line end string::        
* Item face::                   
   


File: versor.info,  Node: Multi line level display,  Next: Use face attributes,  Prev: Status,  Up: Status

9.3.2.1 Multi line level display
................................

 Type: boolean  Default value: (and (boundp 'emacs-major-version
 					     (>= emacs-major-version 21)) Whether to use multi-line
indication of the current meta-level and level. 


File: versor.info,  Node: Use face attributes,  Next: Highlight with brackets,  Prev: Multi line level display,  Up: Status

9.3.2.2 Use face attributes
...........................

 Type: boolean  Whether to use face attributes, as provided from
Emacs 21 onwards.  If these are available, it'll normally make
sense to use them. See also versor-highlight-with-brackets. 


File: versor.info,  Node: Highlight with brackets,  Next: Change cursor color,  Prev: Use face attributes,  Up: Status

9.3.2.3 Highlight with brackets
...............................

 Type: boolean  Default value: (not versor-use-face-attributes
 Whether to use brackets around highlighted items in status
feedback.  This is useful if you can't use face attributes (see
versor-use-face-attributes). 


File: versor.info,  Node: Change cursor color,  Next: Item attribute,  Prev: Highlight with brackets,  Up: Status

9.3.2.4 Change cursor color
...........................

 Type: boolean  Default value: t  Whether to use the cursor
color to indicate the level.  This refers to the normal GNUemacs
cursor rather than the versor selection (highlight) cursor.  See
versor-item-attribute for the attribute used to change the colour (or
other aspect) of the block cursor. 


File: versor.info,  Node: Item attribute,  Next: Try to display whole item,  Prev: Change cursor color,  Up: Status

9.3.2.5 Item attribute
......................

 Type: (set (const :background (const :foreground) (const
:underline))  Default value: (:background)  An attribute to use
to indicate the current item.  This is looked up in the current
dimension, to get the value to set it to. For example, if
versor-item-attribute is :background, :background is looked up in the
current dimension, to find the colour to set the background to. 
You can only use this from Emacs 21 onwards. 


File: versor.info,  Node: Try to display whole item,  Next: Mode line begin string,  Prev: Item attribute,  Up: Status

9.3.2.6 Try to display whole item
.................................

 Type: boolean  Default value: t  Whether to try to display
the whole item after each movement.  This recenters the text, if
possible, so both the start and the end of it are visible. 


File: versor.info,  Node: Mode line begin string,  Next: Mode line end string,  Prev: Try to display whole item,  Up: Status

9.3.2.7 Mode line begin string
..............................

 Type: string  Default value:  <  String corresponding to
bracket for beginning of versor markers according to versor-reversed.



File: versor.info,  Node: Mode line end string,  Next: Item face,  Prev: Mode line begin string,  Up: Status

9.3.2.8 Mode line end string
............................

 Default value: (if versor-reversible ==> >  Type: string 
String corresponding to bracket for end of versor markers according to
versor-reversed. 


File: versor.info,  Node: Item face,  Prev: Mode line end string,  Up: Status

9.3.2.9 Item face
.................

 Face to use for versor items 


File: versor.info,  Node: Other control,  Prev: Status,  Up: Using Configure

9.3.3 Other control
-------------------



* Menu:

* Statement insertion with dummy value::  
* Per buffer::                  
* Auto change for modes::       
* Text in code::                
* Announce text in code::       
* Text faces::                  
* Live commentary::             
* Display full choices::        
* Flexi choose upstring::       
* Flexi choose topstring::      
   


File: versor.info,  Node: Statement insertion with dummy value,  Next: Per buffer,  Prev: Other control,  Up: Other control

9.3.3.1 Statement insertion with dummy value
............................................

 Type: boolean  Default value: nil  Whether versor statement
insertion puts a placeholder value in when adding something.  This
tries to avoid changing the semantics, for example, it uses "true"
when adding "and" or "if".  You can then change the value, using
the versor alterations system. 


File: versor.info,  Node: Per buffer,  Next: Auto change for modes,  Prev: Statement insertion with dummy value,  Up: Other control

9.3.3.2 Per buffer
..................

 Type: boolean  Default value: nil  Whether to remember the
dimensions separately for each buffer. 


File: versor.info,  Node: Auto change for modes,  Next: Text in code,  Prev: Per buffer,  Up: Other control

9.3.3.3 Auto change for modes
.............................

 Default value: t  Whether to change the dimension on changing
modes.  Type: boolean 


File: versor.info,  Node: Text in code,  Next: Announce text in code,  Prev: Auto change for modes,  Up: Other control

9.3.3.4 Text in code
....................

 Type: boolean  Default value: t  Whether versor should
switch dimensions for string literals and comments.  This requires
font-lock-mode to be used.  The current dimensions are then
remembered separately, and switch to the last one used in that kind
of place, as point moves between code, comments and strings.  See
versor-text-faces for the faces used to recognize this, building on
font-lock-mode. 


File: versor.info,  Node: Announce text in code,  Next: Text faces,  Prev: Text in code,  Up: Other control

9.3.3.5 Announce text in code
.............................

 Type: boolean  Default value: t  Whether versor-text-in-code
should put up messages telling you when changes the dimension. 


File: versor.info,  Node: Text faces,  Next: Live commentary,  Prev: Announce text in code,  Up: Other control

9.3.3.6 Text faces
..................

 Default value: '(font-lock-string-face font-lock-comment-face) 
Faces which versor regards as being text rather than code. See
versor-text-in-code-function for how this is used. 


File: versor.info,  Node: Live commentary,  Next: Display full choices,  Prev: Text faces,  Up: Other control

9.3.3.7 Live commentary
.......................

 Type: boolean  Default value: nil  Whether to make a live
commentary on versor and other activities. 


File: versor.info,  Node: Display full choices,  Next: Flexi choose upstring,  Prev: Live commentary,  Up: Other control

9.3.3.8 Display full choices
............................

 Type: boolean  Default value: t  Whether to display in full
the range of choices at each level of a treewise chooser. 


File: versor.info,  Node: Flexi choose upstring,  Next: Flexi choose topstring,  Prev: Display full choices,  Up: Other control

9.3.3.9 Flexi choose upstring
.............................

 Type: string  Default value: [Up]  The label to indicate
going back up the tree. 


File: versor.info,  Node: Flexi choose topstring,  Prev: Flexi choose upstring,  Up: Other control

9.3.3.10 Flexi choose topstring
...............................

 Type: string  Default value: [Top]  The label to indicate
going straight back up to the top of the tree.  


File: versor.info,  Node: Analysis,  Next: Versor and research,  Prev: Setup,  Up: Top

10 Versor use analysis
**********************

 Versor provides some facilities for measuring how much you are
using it, and how much you are using non-Versor commands, and how the
two are mixed. This is partly because Versor was developed as part of
some research on the psychology of programming *Note Versor and
research::, and partly so that you can tune your own computer use,
and partly to get feedback on what needs to be added to Versor to
make it a complete way to edit programs.  


File: versor.info,  Node: Versor and research,  Next: Command Index,  Prev: Analysis,  Up: Top

11 Versor and research
**********************

 Versor was developed as part of some research on the psychology of
programming (*note Versor and research::), to see how much people
editing programs will use the facility to work at a higher level of
abstraction than the character-by-character, line-by-line level, and
how much, and when, they resort to traditional commands despite more
powerful ones being available.  Versor will be used in controlled
experimental conditions for this, but to gather wider information,
the author encourages you to use Versor's use analysis features
(*note Analysis::) and send in the results, once you have been using
Versor for a while. 


File: versor.info,  Node: Command Index,  Next: Concept Index,  Prev: Versor and research,  Up: Top

Command Index
*************

 [index ]
* Menu:

* Convert selection to variable:         Convert to variable.   (line 6)
* Zooming commands:                      Zooming.               (line 6)




File: versor.info,  Node: Concept Index,  Prev: Command Index,  Up: Top

Concept Index
*************

 [index ]
* Menu:

* cartesian co-ordinates:                Cartesian.             (line 6)
* dimensions, cartesian:                 Cartesian.             (line 6)
* Zooming:                               Zooming.               (line 6)

 



Tag Table:
Node: Top150
Node: Introduction6897
Node: Aims9278
Node: Concepts10652
Node: Coordinates and dimensions11441
Node: The selection11876
Node: Familiarization12435
Node: Zooming14160
Node: Switching coordinate systems15007
Node: Editing with the selection15936
Node: Deleting the selection16299
Node: Inserting using the selection16859
Node: Extending18132
Node: Dimensions18631
Node: Cartesian19421
Node: Structural19926
Node: Text20426
Node: Structured Text21240
Node: Tables22795
Node: Program23242
Node: Further commands25948
Node: Deletion26451
Node: Insertion27010
Node: Alteration29217
Node: DWIM30724
Node: Refactoring32307
Node: Expression handling34514
Node: Convert to variable36200
Node: Convert to function37111
Node: Surround with call37794
Node: Remove call38252
Node: Statement handling38650
Node: Unify Statements39550
Node: Make conditional39903
Node: Make repeating40495
Node: Remove control40860
Node: Decision point41191
Node: Summary of refactoring41631
Node: Advanced features42321
Node: Detect text in code42633
Node: Per-buffer dimensions43203
Node: Per-mode dimensions43704
Node: Accessibility44167
Node: Pedals44763
Node: Reversing46195
Node: Voice input46908
Node: Flexi-choose47424
Node: Other input devices48284
Node: Versor and Languide49307
Node: Setup49905
Node: General configuration50461
Node: Dimensions available52140
Node: Using Configure53040
Node: Motion53291
Node: Allow move to end of last53678
Node: Move out when at end54388
Node: Statement up to next54899
Node: Level wrap55292
Node: Meta level wrap55664
Node: Reversible56051
Node: Status56424
Node: Multi line level display56917
Node: Use face attributes57283
Node: Highlight with brackets57665
Node: Change cursor color58079
Node: Item attribute58563
Node: Try to display whole item59168
Node: Mode line begin string59555
Node: Mode line end string59883
Node: Item face60210
Node: Other control60363
Node: Statement insertion with dummy value60852
Node: Per buffer61375
Node: Auto change for modes61657
Node: Text in code61923
Node: Announce text in code62507
Node: Text faces62813
Node: Live commentary63153
Node: Display full choices63426
Node: Flexi choose upstring63737
Node: Flexi choose topstring64020
Node: Analysis64304
Node: Versor and research64896
Node: Command Index65682
Node: Concept Index65985

End Tag Table
